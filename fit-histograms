#!/usr/bin/env python3
from __future__ import print_function, division
import h5py
import numpy as np
import sys

if __name__ == '__main__':
    from argparse import ArgumentParser
    import ROOT
    import matplotlib.pyplot as plt

    parser = ArgumentParser(description='Fit SPE and sodium charge histograms')
    parser.add_argument('filenames',nargs='+',help='input filenames (ROOT format)')
    parser.add_argument('--sodium', default=False, action='store_true', help='flag to indicate data is from a sodium source')
    parser.add_argument('--plot', default=False, action='store_true', help='plot the waveforms and charge integral')
    parser.add_argument('--BV', type=int,default=42, help='Bias Voltage input')
    #parser.add_argument('--peakper', type=double, default=0, help='Direct change of maximum percentage change from maximum peak')
    parser.add_argument('--pdf', default=False, action='store_true', help='Save the fit canvas as pdf')
    parser.add_argument('--ObjKeep', type=int,default=2,  help='Number of objects to fit')

    args = parser.parse_args()
    
    canvas_count = 1

    for filename in args.filenames:
        f = ROOT.TFile(filename,"UPDATE")
        keycount=0
        for key in f.GetListOfKeys():
            #print("***KEYPRINT")
            #print(key)
            #print(key.GetTitle())
            if (keycount>0):
                if(key.GetTitle()==keyold.GetTitle()):
                   # print("EQUAL")
                    continue
            keycount+=1
            keyold=key
            #if keycount>2:
            #    break

            #if keycount>args.ObjKeep:# Only gets channel 1
            #    break
                # Argument to delete all previous fits. Not working, related to TF1 class?
                # Each time the code executes 2 new keys are created in the file.
                #h.Reset("ICESM")

            h = key.ReadObj()

            if h.ClassName() != 'TH1F' and h.ClassName() != 'TH1D':
                continue

            print(h.GetName())
           

            if args.sodium:
                # Peak searching using the TSpectrum class. See ROOT
                # documentation for details.
                # https://root.cern.ch/root/htmldoc/guides/spectrum/Spectrum.html#processing-and-visualization-functions

                # *** depending on the overvoltage the peak dimension with respect to the noise makes changes needed on the second value. A more efficient way would be to create a bisection and stop it when it detects only the 2 biggest peaks.
                #The number of found peaks and their positions are written into the members fNpeaks and fPositionX
                #Search 	( 	const TH1 *  	hin,
	        #Double_t  	sigma = 2,
		#Option_t *  	option = "",
		#Double_t  	threshold = 0.05 #Peaks with  amplitude < th*Amax are discarded. If too small -> detects peaks after the 511 peak. The code right now detects the last peak detected as the 511 peak. Other option is to iterate through the y positions and keep always the latest peak with an increase over the previous ones? first derivative with respect to max/min closest to zero 
	) 	
                spec = ROOT.TSpectrum()
                if(args.BV==42):
                    n_pks = spec.Search(h, 1, "", 0.01)
                    #n_pks = spec.Search(h, 1, "", 0.999)
                elif(args.BV>42):
                    n_pks = spec.Search(h, 1, "", 0.005)
                else:
                    # print("Wrong BV<42")
                    sys.exit("Wrong BV<42")


                x_pos = spec.GetPositionX()
                y_pos = spec.GetPositionY()

                x_pos = np.array([x_pos[i] for i in range(n_pks)])
                y_pos = np.array([y_pos[i] for i in range(n_pks)])

                ind = np.argsort(x_pos)
                x_pos = x_pos[ind]
                y_pos = y_pos[ind]
                                      
                n = len(x_pos)

                peak = x_pos[-1]

                f1 = ROOT.TF1("f1","gaus",peak-200,peak+200)

                r = h.Fit(f1, 'ILMSR+')

                r = r.Get()

                if not r.IsValid():
                    print("Fit error!")
                    continue

                print("511 peak = %.4f +/- %.4f" % (f1.GetParameter(1), f1.GetParError(1)))

                h.Write()
                if args.pdf:
                    print("*** Print PDF 1:")
                    c = ROOT.TCanvas("c%i" % canvas_count)
                    canvas_count += 1
                    canvas_count += 1
                    h.Draw()
                    c.Update()
                    prname=filename[:len(filename)-5]
                    c.Print("./FiguresFit/"+prname+"_Key_"+str(keycount)+".pdf")
                elif args.plot:
                    c = ROOT.TCanvas("c%i" % canvas_count)
                    canvas_count += 1
                    h.Draw()
                    c.Update()
            else:

                print("Single P.h.e:")
                n = 10
                string = "[0]*(" + "+".join(["TMath::Poisson(%i,[2])*TMath::Gaus(x-[1],[3]*%i,TMath::Sqrt([4]^2+[5]^2*%i))" % (i,i,i) for i in range(0,n)]) + ")"

                #string = "+".join(["gaus(%i)" % i for i in range(0,n*3,3)])

                print("Using the following fit string: '%s'" % string)
                # *** we could set a threshold/break to find when the Y axis /charge goes above a certain values from the smallest X to set the first value (-0.4 as of the time of this comment)
                f1 = ROOT.TF1("f1",string,-0.4,4.)
                f1.SetParameter(0,1000)
                f1.SetParLimits(0,1,100000)
                f1.SetParameter(1,-0.08)
                f1.SetParLimits(1,-1,1)
                f1.SetParameter(2,0.065)
                f1.SetParLimits(2,0.0000001,0.1)
                f1.SetParameter(3,3.)
                f1.SetParLimits(3,0.1,5.)
                f1.SetParameter(4,0.17)
                f1.SetParLimits(4,0.1,10)
                f1.SetParameter(5,0.17)
                f1.SetParLimits(5,0.1,10)

                #for j, i in enumerate(range(0,n*3,3)):
                #    print(i)
                #    f1.SetParameter(i,y_pos[j])
                #    f1.SetParameter(i+1,x_pos[j])
                #    f1.FixParameter(i+1,x_pos[j])
                #    f1.SetParameter(i+2,0.02)
                #    f1.FixParameter(i+2,0.02)

                #r = h.Fit(f1, 'ILMSRN+')
                r = h.Fit(f1, 'SR+')

                #for j, i in enumerate(range(0,n*3,3)):
                #    print(i)
                #    f1.ReleaseParameter(i)
                #    f1.ReleaseParameter(i+1)
                #    f1.ReleaseParameter(i+2)

                #r = h.Fit(f1, 'ILMSR+')

                r = r.Get()

                if not r.IsValid():
                    print("Fit error!")
                    continue

                #print("peak 1 = %.4f +/- %.4f" % (f1.GetParameter(1), f1.GetParError(1)))
                #if n > 1:
                #    print("peak 2 = %.4f +/- %.4f" % (f1.GetParameter(4), f1.GetParError(4)))

                h.Write()
                #print(args.plot)
                #print(args.pdf)
                if args.plot:
                    c = ROOT.TCanvas("c%i" % canvas_count)
                    canvas_count += 1
                    h.Draw()
                    c.Update()
                if args.pdf:
                    print("***Print to PDF 2:")
                    c = ROOT.TCanvas("c%i" % canvas_count)
                    canvas_count += 1
                    h.Draw()
                    c.Update()
                    prname=filename[:len(filename)-5]
                    c.Print("./FiguresFit/"+prname+"_Key_"+str(keycount)+".pdf")
                    
        if args.plot:
            input()
        f.Close()
