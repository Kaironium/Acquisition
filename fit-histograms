#!/usr/bin/env python3
from __future__ import print_function, division
import h5py
import numpy as np

if __name__ == '__main__':
    from argparse import ArgumentParser
    import ROOT
    import matplotlib.pyplot as plt

    parser = ArgumentParser(description='Fit SPE and sodium charge histograms')
    parser.add_argument('filenames',nargs='+',help='input filenames (ROOT format)')
    parser.add_argument('--sodium', default=False, action='store_true', help='flag to indicate data is from a sodium source')
    parser.add_argument('--plot', default=False, action='store_true', help='plot the waveforms and charge integral')
    args = parser.parse_args()

    for filename in args.filenames:
        f = ROOT.TFile(filename)
        for key in f.GetListOfKeys():
            h = key.ReadObj()

            if h.ClassName() != 'TH1F' or h.ClassName() == 'TH1D':
                continue

            print(h.GetName())

            if args.sodium:
                
                """
                Peak searching using the TSpectrum class. See ROOT documentation for details.
                https://root.cern.ch/root/htmldoc/guides/spectrum/Spectrum.html#processing-and-visualization-functions
                """
                
                spec = ROOT.TSpectrum()
                n_pks = spec.Search(h, 0.8, "", 0.05)
                x_pos = spec.GetPositionX()
                y_pos = spec.GetPositionY()
                                      
                for i in range(n_pks):
                    pk = [x_pos[i], y_pos[i]]
                    print
                    print(pk)
                    
                    # Finding fit window around peak using a threshold value.
                    
                    thres = 0.40
                    
                    win_lb = h.FindBin(pk[0])
                    win_ub = win_lb
                    while h.GetBinContent(win_lb) > thres * pk[1]:
                        win_lb = win_lb - 1
                    while h.GetBinContent(win_ub) > thres * pk[1]:
                        win_ub = win_ub + 1
                    print(bins[win_lb], h.GetBinContent(win_lb), bins[win_ub], h.GetBinContent(win_ub))
                    
                    r = h.Fit('gaus', 'ILRSQ+', '', h.GetBinCenter(win_lb), h.GetBinCenter(win_ub))
                    r = r.Get()
                    r.Print("V")
                    r.Write()
                    h.Draw()
                    
                    
                    p0 = r.Parameter(0)
                    p1 = r.Parameter(1)
                    p2 = r.Parameter(2)
            
                    # 100 linearly spaced numbers
                    x = np.linspace(bins[win_lb], bins[win_ub], 100)
                    # the function, which is a gaussian here
                    y = p0*np.exp(-0.5*((x-p1)/p2)**2)
                
                    if args.plot:
                        plt.figure()
                        plt.hist(charge[channel],bins=bins,histtype='step',label=channel)
                        plt.xlabel("Charge (pC)")
                        plt.legend()
                        plt.plot(x, y, 'r')

            if args.laser:
                spec = ROOT.TSpectrum()
                n_pks = spec.Search(h, 0.8, "", 0.05)
                x_pos = spec.GetPositionX()
                y_pos = spec.GetPositionY()
                                      
                for i in range(n_pks):
                    pk = [x_pos[i], y_pos[i]]
                    print
                    print(pk)
                    
                    #Select threshold for fit window for each of the single photon peaks
                    thres = [0.2, 0.3, 0.4]
                    
                    win_lb = h.FindBin(pk[0])
                    win_ub = win_lb
                    if i == 0:
                        while h.GetBinContent(win_lb) > thres[0] * pk[1]:
                            win_lb = win_lb - 1
                        while h.GetBinContent(win_ub) > thres[0] * pk[1]:
                            win_ub = win_ub + 1
                    elif i == 1:
                        while h.GetBinContent(win_lb) > thres[1] * pk[1]:
                            win_lb = win_lb - 1
                        while h.GetBinContent(win_ub) > thres[1] * pk[1]:
                            win_ub = win_ub + 1
                    elif i == 2:
                        while h.GetBinContent(win_lb) > thres[2] * pk[1]:
                            win_lb = win_lb - 1
                        while h.GetBinContent(win_ub) > thres[2] * pk[1]:
                            win_ub = win_ub + 1
                    
                    print(bins[win_lb], h.GetBinContent(win_lb), bins[win_ub], h.GetBinContent(win_ub))
                    
                    r = h.Fit('gaus', 'ILRSQ+', '', h.GetBinCenter(win_lb), h.GetBinCenter(win_ub))
                    r = r.Get()
                    r.Print("V")
                    r.Write()
                    h.Draw()
                    
                    
                    p0 = r.Parameter(0)
                    p1 = r.Parameter(1)
                    p2 = r.Parameter(2)
            
                    # 100 linearly spaced numbers
                    x = np.linspace(bins[win_lb], bins[win_ub], 100)
                    # the function, which is a gaussian here
                    y = p0*np.exp(-0.5*((x-p1)/p2)**2)
        f.Close()
